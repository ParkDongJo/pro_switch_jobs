https://frontend-fundamentals.com/code-quality/code/examples/use-page-state-readability.html

# 맥락 줄이기
### 같이 실행되지 않는 코드 분리
가독성 지적
- 2가지의 권한 상태를 하나의 컴포넌트 안에서 한 번에 처리하고 있어
개선
- 사용자가 보기 전용 권한을 가질 때와 일반 사용자일 때를 완전히 나누어서 관리하도록 하는 코드

SOLID 원칙
- 단일성의 원칙

동의하는 부분
- 컴포넌트의 역할이 작을수록 가독성 높음, 결합도 낮음
- 조건문이 간결해지면서 JSX 의 깊이가 줄어듬

#### 생각해볼점
역할(권한)은 어디까지 쪼개야할까? 기준은 뭘까?

----
### 구현 상세 추상화하기
예시 1>
추상화 지적
- 각 변수나 콜벡들을 읽어야 이해가 된다.

개선
- Wrapper 객체 사용
	- AuthGuard 로 로그인 체크만 하는 컨테이너를 만든다.
- HOC 사용
	- hoc 에 넣고, 로그인 체크를 hoc 에서 한다.

예시 2>
가독성 지적
- 맥락이 하나여야 한다.
응집도 지적
- 관련있는 로직이 서로 거리가 멀다.

개선
- 관련있는 로직을 하나로 묶어서 추상화된 컴포넌트로 제공


코드에서 추상화가 가지는 힘과 중요성

#### 생각해볼점
어디까지 추상화 할것이냐


#### 주고받은 의견



----

### 로직 종류에 따라 합쳐진 함수 쪼개기

가독성
- 가지고 있는 책임이 무한대로 늘어날 가능성이 높다
성능
- 굳이 쓰고 있지 않은 상태가 변경되어도 렌더링 된다


개선
- 각 파라미터마다 hooks 로 만들어 준다

의문점
- 그럼 hooks 가 너무 많아지는거 아닌가??
- 파일 하나에서 여러 Hooks 를 export 하는 식으로? 하면 좀 괜찮을지도
- 사용부에서는 useCardId, useStatementId ... 등등으로 코드가 꽉차는거 아닌가?


#### 생각해볼점
- hooks 를 사용하는 사용부로 코드가 몰리지 않을까?
- 생각해보면, query param의 수는 한정적일수도


rules 적용
[awesome-cursorrules](https://github.com/PatrickJS/awesome-cursorrules)
https://gist.github.com/toy-crane/dde6258997519d954063a536fc72d055


# 이름 붙이기
----
# 복잡한 조건에 이름 붙이기
### 조건에 이름을 붙이는 것이 좋을 때[​](https://frontend-fundamentals.com/code-quality/code/examples/condition-name.html#%E1%84%8C%E1%85%A9%E1%84%80%E1%85%A5%E1%86%AB%E1%84%8B%E1%85%A6-%E1%84%8B%E1%85%B5%E1%84%85%E1%85%B3%E1%86%B7%E1%84%8B%E1%85%B3%E1%86%AF-%E1%84%87%E1%85%AE%E1%87%80%E1%84%8B%E1%85%B5%E1%84%82%E1%85%B3%E1%86%AB-%E1%84%80%E1%85%A5%E1%86%BA%E1%84%8B%E1%85%B5-%E1%84%8C%E1%85%A9%E1%87%82%E1%84%8B%E1%85%B3%E1%86%AF-%E1%84%84%E1%85%A2)

- **복잡한 로직을 다룰 때**: 조건문이나 함수에서 복잡한 로직이 여러 줄에 걸쳐 처리되면, 이름을 붙여 함수의 역할을 명확히 드러내는 것이 좋아요. 이렇게 하면 코드 가독성이 높아지고, 유지보수나 코드 리뷰가 더 쉬워져요.
    
- **재사용성이 필요할 때**: 동일한 로직을 여러 곳에서 반복적으로 사용할 가능성이 있으면, 변수나 함수를 선언해 재사용할 수 있어요. 이를 통해 코드 중복을 줄이고 유지보수가 더 쉬워져요.
    
- **단위 테스트가 필요할 때**: 함수를 분리하면 독립적으로 단위 테스트를 작성할 수 있어요. 단위 테스트는 함수가 올바르게 동작하는지 쉽게 확인할 수 있어, 복잡한 로직을 테스트할 때 특히 유용해요.
    

#### 의견
- 예제에 filter, some 의 함수를 따로 빼서 이름을 붙이는 것도 맥락이 더 깔끔하지 않냐?
```typescript
const matchedProducts = products.filter((product) => { const hasTargetCategory = product.categories.some( (category) => category.id === targetCategory.id ); const hasPriceInRange = product.prices.some( (price) => price >= minPrice && price <= maxPrice ); return hasTargetCategory && hasPriceInRange; });
```
아래 코드는 어딘가에서 재사용하고 있을 때, 유리할 것 같다
```typescript
const isCategoryMatched = (product, targetCategoryId) => product.categories?.some(({ id }) => id === targetCategoryId); const isPriceInRange = (product, min, max) => product.prices?.some((price) => price >= min && price <= max); const matchedProducts = products.filter( (product) => isCategoryMatched(product, targetCategory.id) && isPriceInRange(product, minPrice, maxPrice) );
```
### 조건에 이름을 붙이지 않아도 괜찮을 때[​](https://frontend-fundamentals.com/code-quality/code/examples/condition-name.html#%E1%84%8C%E1%85%A9%E1%84%80%E1%85%A5%E1%86%AB%E1%84%8B%E1%85%A6-%E1%84%8B%E1%85%B5%E1%84%85%E1%85%B3%E1%86%B7%E1%84%8B%E1%85%B3%E1%86%AF-%E1%84%87%E1%85%AE%E1%87%80%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B5-%E1%84%8B%E1%85%A1%E1%86%AD%E1%84%8B%E1%85%A1%E1%84%83%E1%85%A9-%E1%84%80%E1%85%AB%E1%86%AB%E1%84%8E%E1%85%A1%E1%86%AD%E1%84%8B%E1%85%B3%E1%86%AF-%E1%84%84%E1%85%A2)

- **로직이 간단할 때**: 로직이 매우 간단하면, 굳이 이름을 붙이지 않아도 돼요. 예를 들어, 배열의 요소를 단순히 두 배로 만드는 `arr.map(x => x * 2)`와 같은 코드는 이름을 붙이지 않아도 직관적이에요.
    
- **한 번만 사용될 때**: 특정 로직이 코드 내에서 한 번만 사용되며, 그 로직이 복잡하지 않으면 익명 함수에서 직접 로직을 처리하는 것이 더 직관적일 수 있어요.



# 매직 넘버 이름붙이기

숫자나 값을 의미를 가지는 상수 선언


# 그 외에 적용해 볼 수 있을 점
타입 정의
- 유틸 타입으로 매번 연상을 할 수도 있지만, 이름을 붙여서 사용 하는 경우
	- 재사용 가능할 때
	- 연산이 복잡할 때




# 시점 이동 줄이기

코드의 시점 이동은 몇 개까지가 적절한가? 3개?
코드의 시점 이동은 있을 수 밖에 없지 않나?
예제의 코드는 컴포넌트의 덩치가 작기때문에, 제시한 방법으로 해결이 가능하지만
컴포넌트의 크기가 클수록 위의 제시 방법은 힘들다.

조건문을 객체로 변경하는 기법을 자주 쓴다.

그런데 그렇게 하면 좋은 조건문이 복잡해 지지 않나


<원용님 의견>
두괄식 대화법이라고 한다면, 오히려 가장 대표적인 컴포넌트나 코드를 가장 상단에 두는게 맞지 않느냐
상수는 상단에 둔다

<승연님 조언>
테이블 정의도 AI를 활용한다.
- 테이블 타입 정의만 잘해줘도 AI 가 테이블 셋을 잘 만들어준다
- 피그마 이미지를 스샷 찍어서 학습 시키고, 코드 작성을 시키면 피그마에 정의된 테이블 컬럼으로 명령을 내릴 수 있다.


# 삼항 연산자 단순하게 하기
복잡한 삼항연산자는 if 문으로 풀어서 사용한다.

삼항 연산자 복잡함의 기준 선은?
- 삼항 연산 조건이 2개 이상일때

또다른 해결방법은?
- 삼항연산을 쪼갠다
- ts pattern 를 쓴다.
- switch case -> union satisfies


<원용님 방법>
삼항 연산자로 내가 생각하는 조건들을 모두 커버할 수 있다. 생각하는 조건을 삼항연산자로 풀어놓고 리팩토링을 AI 로 맡긴다.
괜찮은 접근방법인 것 같음!!!!

<승연님 조언>
sonacube eslint 가 있다.



# 예측 가능성

## A. 이름 겹치지 않게 관리하기
같은 이름을 가지는 함수나 변수는 동일한 동작을 해야 해요. 작은 동작 차이가 코드의 예측 가능성을 낮추고, 코드를 읽는 사람에게 혼란을 줄 수 있어요

함수 내부에 숨은 로직이 드러날 수 있게끔 이름 짓기


## B. 같은 종류의 함수는 반환타입 통일하기
API 호출과 관련된 Hook들처럼 같은 종류의 함수나 Hook이 서로 다른 반환 타입을 가지면 코드의 일관성이 떨어져서, 같이 일하는 동료들이 코드를 읽는 데에 헷갈릴 수 있어요.

예시
- useUserQuery, useServiceTimeQuery 는 동일하게 query 타입을 반환하는 것이 좋다
- checkIdValid, checkIsAgeValid 는 동일하게 boolean 타입을 반환하는 것이 좋다.

예시에서 useUser 의 이름을 useUserQuery 로 변경하는 것이 좋지 않나?


## C. 숨은 로직 드러내기
함수나 컴포넌트의 이름, 파라미터, 반환 값에 드러나지 않는 숨은 로직이 있다면, 함께 협업하는 동료들이 동작을 예측하는 데에 어려움을 겪을 수 있어요.

키포인트 -> 함수의 이름과 파라미터, 반환 타입으로 예측할 수 있는 로직만 구현 부분에 남기세요.

결국 역할분리 -> 단일 책임

서로 다른 역할의 코드는 분리하고, 그걸 상위 위치에서 조합하는 형태로!

당연하지만 재미있는 질문과 답변들
![[Pasted image 20250617131646.png]]

log는
- proxy
- interceptor
- middleware
로 하는게 좋지 않느냐?


# 응집도
### 함께 수정되는 파일을 같은 디렉토리에 두기
파일들을 쉽게 만들고, 찾고, 삭제할 수 있도록 올바른 디렉토리 구조를 갖추는 것이 중요해요.

```
└─ src
   ├─ components
   ├─ constants
   ├─ containers
   ├─ contexts
   ├─ remotes
   ├─ hooks
   ├─ utils
   └─ ...
```

어떤 코드가 어떤 코드를 참조하는지 쉽게 확인할 수 없어요.


```
└─ src
   │  // 전체 프로젝트에서 사용되는 코드
   ├─ components
   ├─ containers
   ├─ hooks
   ├─ utils
   ├─ ...
   │
   └─ domains
      │  // Domain1에서만 사용되는 코드
      ├─ Domain1
      │     ├─ components
      │     ├─ containers
      │     ├─ hooks
      │     ├─ utils
      │     └─ ...
      │
      │  // Domain2에서만 사용되는 코드
      └─ Domain2
            ├─ components
            ├─ containers
            ├─ hooks
            ├─ utils
            └─ ...
```


다음과 같이 한 도메인(`Domain1`)의 하위 코드에서 다른 도메인(`Domain2`)의 소스 코드를 참조한다고 생각해 볼게요.


# 매직넘버 없애기
**매직 넘버**(Magic Number)란 정확한 뜻을 밝히지 않고 소스 코드 안에 직접 숫자 값을 넣는 것을 말해요

```
async function onLikeClick() {
  await postLike(url);
  await delay(300);
  await refetchPostLike();
}
```

Q) 왜 이 300 매직넘버가 응집도와 관련있지??


## 폼의 응집도 생각하기
 Form을 관리할 때는 2가지의 방법으로 응집도를 관리
 - 필드 단위 응집도
	 - 특정 필드의 유지보수가 쉬워짐
	 - 필드의 검증 로직이 독립적이어서 다른 필드에 영향을 주지 않음
 - 폼 전체단위 응집도
	 - 폼 전체의 검증이 한 곳에서 관리되어 로직이 간결
	 - 필드 간의 결합도가 높아지므로 폼의 재사용성은 떨어질 수 있음


 필드 단위와 폼 전체 단위 중 상황에 적합한 방식을 선택해야 함

필드 단위 응집도
- 독립적인 검증이 필요할 때
- 재사용이 필요할 때

폼 전체 단위 응집
- 단일 기능을 나타낼 때
- 단계별 입력이 필요할 때
- 필드간 의존성이 있을 때

각 필드단위로는 독립성을 atom 단위로 유지하고 있돼, 폼전체 단위의 응집도로 뭉쳐진 각각의 도메인 폼을 관리하면 된다.


# 결합도


## 책임을 하나씩 관리하기
쿼리 파라미터, 상태, API 호출과 같은 로직의 종류에 따라서 함수나 컴포넌트, Hook을 나누지 마세요


## 중복 코드 허용하기
중복 코드를 하나의 컴포넌트나 Hook으로 공통화하면, 좋은 코드의 특징 중 하나인 응집도를 챙겨서, 함께 수정되어야 할 코드들을 한꺼번에 수정할 수 있어요.

그렇지만, 불필요한 결합도가 생겨서, 공통 컴포넌트나 Hook을 수정함에 따라 영향을 받는 코드의 범위가 넓어져서, 오히려 수정이 어려워질 수도 있어요.

다소 반복되어 보이는 코드일지 몰라도, 중복 코드를 허용하는 것이 좋은 방향일 수 있어요.


## Props Drilling 지우기
Props Drilling은 부모 컴포넌트와 자식 컴포넌트 사이에 결합도가 생겼다는 것을 나타내는 명확한 표시

- 조합(Composition) 패턴 활용
- Context API 활용


AI 에게 물어볼 때, 명료하게 질문하는 것이 중요

- 어때? 어떻게 생각해? 이런 질문을 하면 안됨
- AI 모델마다 좋아하는 단어가 따로있다.
- AI 가 답변을 낼 수 있는 질문으로 해야한다 - 장단점을 설명해줘


# 명예의 전당
https://frontend-fundamentals.com/code-quality/code/community/good-discussions.html

결정!
```
export const Status = {
  BANNED: 'Banned',
  INACTIVE: 'Inactive',
  PENDING: 'Pending',
  ACTIVE: 'Active',
} as const;

export type Status = typeof Status[keyof typeof Status];
```


이건 어떤가?
```
function foo() {
  // Validation Logic
  if (!ref) return;

  // Main Logic
  if (typeof ref.current === "number") {
    return ref.current + 1;
  }

  if (typeof ref.current === "function") {
    return ref.current();
  }

  return 0;
}
```



- **의도 명확성 vs 간결함**: `if (!value)`는 `"", undefined, null, 0`을 모두 포함하는데, 의도한 조건인지 불분명할 수 있음.
- **예측 가능성 문제**: 불리언이 아닌 값이 조건문에서 암묵적으로 변환되면, 코드 유지보수 시 혼란을 초래할 가능성이 있음.
- **오류 가능성**: 특정 값만 체크해야 하는 경우에는 명시적인 비교 (`=== undefined`, `=== ""`)가 더 안전함.
- **도구 활용**: `isNil(value)`, `isString(value)` 같은 헬퍼 함수를 활용해 코드의 명확성을 높이는 방법도 고려 가능.

[  
](https://github.com/toss/frontend-fundamentals/edit/main/fundamentals/code-quality/code/community/good-discussions.md)
