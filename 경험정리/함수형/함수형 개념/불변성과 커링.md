
## 출발하면서

함수형

## 불변성을 위한 노력들

앞서 진행한 함수형 프로그래밍 세미나에서 부수효과를 분리해내고 순수함수를 늘려가는 것이 중요하다고 말씀드렸습니다. 여기서 함수에 인자로 넘어오는 데이터는 ‘값의 복사’ 또는 ‘주소의 복사’ 가 일어납니다.

‘값의 복사’가 일어나는 Number, String 등등과 같은 ‘원시 타입’들은 신경을 쓸 이유가 없습니다. 하지만 여러분들이 객체와 같은 ‘참조 타입’을 인자로 넘긴다면, ‘주소의 복사’가 일어나기 때문에 신경을 써줘야 합니다. 아래의 예시를 살펴볼까요?

```javascript

const baby = { 
	name: 'zero', 
	age: 0 
}; 

const addAge = (obj, age) => {
	obj.age = age;
	return obj;
};

const person = addAge(person, 40);
console.log(person.age);  // 40

```

동작하는데는 전혀 문제가 없는 코드입니다. setColor 라는 함수는 의도대로 동작을 했습니다. 심지어 입력값을 
받아서 정해진 출력값을 뱉어냅니다.

하지만 이 함수는 불변성을 해치고 있습니다. car 객체를 한번 찍어보면 알 수 있습니다.

```javascript

const car = {
	name: 'ionic',
	color: 'blue',
};

const newCar = setColor(car, 'white');

console.log(newCar.color);  // white
console.log(car.color);   // white

```


객체의 불변성을 보장하기 위해, 어떻게 해야할까요?

두가지 방법이 있습니다.

### 구조적 공유 (카피온 라이트)

첫번째 방법은 copy on write 방법입니다. 객체를 새롭게 생성하여 새로운 변수에 담아주고 값을 변경하는 방법입니다. 그리고 결과물을 리턴할때는 새롭게 생성한 객체를 넘깁니다. 아래 코드를 살펴보죠

```javascript
let person = { name: 'dongjo', age: 38 }; 

const clone = (obj, key, value) => { 
	let result = {...obj}; 
	result[key] = value; 
	return result; 
} 
const person2 = clone(person, 'age', 20); 

console.log(person2.age); // 20 
console.log(person.age); // 38
```

우리가 흔히들 사용하는 … 분해할당은 1차 구조까지 복사가 됩니다. 이를 ‘얕은 복사’라고 하는데요. ‘얕은 복사’가 일어났기 때문에 clone 으로 넘긴 객체 obj 는 1차 데이터까지는 불변성이 보장이 됩니다.

만약 2차, 3차, N차 깊이까지 간다면 재귀를 활용해야합니다.

그 외에 lodash, ramda r같은 라이브러리를 활용한다면 내부적으로 제공되는 함수들을 활용하면 되비낟,

### 방어적 복사
두번째 방법인 방어적 복사입니다. 대중적으로는 Deep Copy 라는 개념으로 알려져 있습니다. 우리가 앞서 살펴본 구조적 공유보다는 비용이 비싼 방법입니다.

일부만 복사를 하는 '구조적 공유'와 달리 '방어적 복사'는 객체 내부의 모든 값을 복사합니다. 간단한 구조의 객체라면 큰 차이가 없겠지만 만약 구조가 복잡한 객체에 '방어적 복사'를 진행한다면, 복사라는 행위가 데이터의 복잢성 만큼 일어나게 됩니다.

그러면 왜? '방어적 복사'를 하는 걸까요?

불변성을 지키기위해 '방어적 복사'가 필요한 때가 있습니다. 



## 커링이라는 함수형 기법

커링 사용법 자체는 너무 쉽습니다. 그런데 커링 같은 기법이 왜 JavaScript에서 가능한지 이해를 한다면, 커링을 더 확실하게 이용하고 유용하게 활용할 수 있습니다. 그렇지 않으면 커링을 사용할때마다 응용할 때마다 ‘이게 맞나??’ 싶을거예요.

그러기 위해서 ‘실행컨텍스트’, ‘클로저’ 를 먼저 이해하는 것이 좋습니다.

### 실행 컨텍스트

실행 컨텍스트는 현재 실행하고 있는 함수 내의 변수, this 값 등을 저장하고 기억하는 JavaScript의 특별한 자료구조입니다. 함수가 실행되면 함수에 대한 실행 컨텍스트가 Call Stack 에 쌓이고, 이 각각의 실행 컨텍스트는 Lexical Environment 저장 구조를 가지게 됩니다.

사실 퉁쳐서 Lexical Environment 이라 명칭되고 있고, 더 세부적으로는 3가지로 구성을 가지게 됩니다.

- Variable Environment
    - environment Record
    - outer Environment Reference
        
- Lexical Environment
    - environment Record
    - outer Environment Reference
        
- This Binding
    

Variable Environment 는 컨텍스트 생성 단계의 정보들을 담게되고, 실행 직전에 생성됩니다. Record 안에서는 대표적으로 함수의 인자 초기값을 undefined 로 맵핑하는 작업들이 이뤄지죠.

Lexical Environment 는 이미 만들어진 Variable Environment의 정보를 우선은 복사해옵니다. 코드가 실행되면서 값이 할당되거나 변경되면 바로 이때 Lexical Environment의 Record에만 저장&기록 됩니다.

여기서 각 환경마다 outer Environment Reference 라는게 있는데, 이는 외부환경을 저장합니다. JavaScript의 Scope chain 이 저장공간 덕분에 가능하게 됩니다.

자 여기까지 따라 오셨나요?

### 클로저

클로저는 사실 JavaScript 만의 개념은 아닙니다. 하지만 JavaScript는 어떻게 클로저가 가능할까요? 그 해답은 바로 앞서 설명했던 실행 컨텍스트의 Lexical Environment 와 관련이 있습니다.

```javascript
function outer() { 
	let x = 10; 
	
	function inner() { 
		console.log(x);
	} 
	return inner; 
} 
const ella = outer(); 
ella(); // x = 10
```

이런 코드가 있다고 해보죠. 이 코드가 실행이 되는 과정은 우선 아래와 같을 겁니다.

- 실행 직전 Variable Environment 만들어 집니다. let, function 등등을 읽고 정보들을 저장하고 초기 값들도 셋팅하겠죠?
- 코드가 실행되면서, Call Stack 에 실행컨텍스트로 쌓입니다. 실행 컨텍스트 당 Lexical Environment 이 만들어지고, 우선은 Variable Environment 복사해서 생성되겠죠.
- 값이 변경되면 Lexical Environment 에도 반영될겁니다.


자! 그러면 위 코드는 아래와 같은 그림을 그리게 될겁니다.

Open image-20240903-141651.png

![image-20240903-141651.png](blob:https://42dot.atlassian.net/43b8a08a-e82b-4913-9c0d-9bb5070db119#media-blob-url=true&id=5aa3ebb3-9f91-4ed7-a4eb-b684d35cfb88&collection=contentId-3242494973&contextId=3242494973&mimeType=image%2Fpng&name=image-20240903-141651.png&size=535716&width=702&height=663&alt=image-20240903-141651.png)

여기서 눈여겨 볼 점은 outer() 실행 컨텍스트는 호출이 되고나서 본인의 소임을 끝내면 Call Stack 에서 POP이 됩니다.

outer()는 실행 되면서 inner()의 참조값을 ella 라는 변수에 담고 사라졌습니다.

이 inner 는 outer의 Lexical Environment에 담겨있고, ella가 inner 의 참조값을 바라보고 있기 때문에, outer의 Lexical Environment의 정보는 가비지 컬렉터의 대상이 되지 않습니다.

덕분에 outer의 Lexical Environment안에 담긴 x 의 값은 여전히 메모리에 함께 살아 있죠!

그리고 inner() 가 실행되면 마찬가지로 해당 실행컨텍스트로 인해 Lexical Environment 할당될것이고 이때 x 라는 변수를 찾을텐데, inner 자체에서는 찾을 수 없으니! outer Environment Reference 의 외부 참조값을 타고 가서 outer의 Lexical Environment 에 있는 x를 참조하게 될 것입니다.

덕분에 우리는 x의 10 라는 값을 함수를 활용해서도 마치 객체의 멤버변수처럼 저장해서 사용할 수 있는거죠!

이게 JavaScript 에서 클로저가 가능하게 하는 내부 흐름입니다. 그리고 이런 Environment(환경) 에 대한 함수의 조합을 클로저라고 부릅니다.

이 클로저가 가능함으로서
- 함수를 통해 모듈화가 가능해지구요.
- 함수를 가지고 캡슐화도 가능해집니다.

마치 객체지향에서 객체가 하는 역할을 함수도 해낼 수 있는 거죠!

그리고 우리가 궁극적으로 알고자 하는 바로 커링이 가능해집니다!!

### 커링
간단한 커링 함수를 살펴보죠.

```javascript
function add(x) { 
	return function(y) { 
		return x + y; 
	}; 
} 
const add5 = add(5); 

console.log(add5(3)); // 8

```

이때, add5 라는 변수에는 add 함수가 실행되면서 add의 내부함수가 생성되어 담겼습니다.

덕분에 최종 결과를 얻기위해서는 한번 더 함수 실행이 필요합니다. 이해가 안가시나요? 위 코드는 아래와 같이 도 실행이 가능합니다.

```javascript
console.log(add(5)(3)); // 8
```

2개의 인자를 한꺼번에 받지 않고, 하나씩 하나씩 차례대로 받고 있습니다. 

클로저라는 걸 앞서 배웠으니, 위 코드에서 인자로 넘어오는 x는 클로저가 적용된다는 걸 쉽게 알 수 있습니다. Lexical Environment 구조에 x 의 정보가 저장되어 있겠죠.

그러니 add5(3) 로 두번째 인자 3을 넣어 함수를 실행 시켰을 때, x 에 저장된 5라는 값과 함께 더해져 8이라는 결과값을 내 뱉을 수 있는 겁니다.

이걸 이해하기 까지 개념의 흐름이 길 뿐이지, 사용법은 굉장히 쉽죠?


## 커링 고급 > Curry 함수
그러면 좀 더 우아하게 커링을 활용해보죠! curry 라는 함수를 아래와 같이 직접 만들고,

```javascript
function curry(fn) {
	return function curried(...args) {
		// 현재까지 전달된 인자 갯수 >= 최초 커링한 함수의 인자 갯수
		if (args.length >= fn.length) {
			return fn.apply(this, args);
		} else {
			// 현재까지 전달된 인자 갯수가 여전히 부족하면
			// 추가로 인자를 받을수 있도록 함수 리턴
			return function(...args2) {
				return curried.apply(this, args.concat(args2));
			}
		}
	}
}

```

a, b, c를 인자로 받아서 합하는 함수를 curry에 넣어서 재생성하고 이를 sum이라고 이름 짓겠습니다.

```javascript

const sum = curry(function(a, b, c) {
	return a + b + c;
});

```

그리고 이 sum은 아래와 같이 활용이 가능합니다.

```javascript

console.log(sum(1, 2, 3));
console.log(sum(1)(2, 3));
console.log(sum(1, 2)(3));
console.log(sum(1)(2)(3));

```

우리가 아는 일반적인 함수 사용과는 틀리죠?!


## 커링 고급 > Partial 함수
커링 뿐만 아니라, 부분적용이라는 개념도 있습니다. 함수의 인자를 다루는 컨셉을 커링과 유사합니다. 단 하나의 차이점이라고 한다면, 

커링은 인자가 많은 다항함수를 여러개의 단항함수들이 중첩한 형태로 변환하는 기법입니다.
부분적용은 여러 인자들 중 일부를 미리 받아놓고, 그 외에 인자들만 받는 함수로 변환하는 기법입니다.

코드를 보면서 이해해 봅시다.

부분 적용 함수를 직접 구현해보자면, 아래와 같이 구현해 볼 수 있습니다.
```javascript
function partial(fn, …params1) {
	return function(…params2) {     
		return fn.apply(null, params1.concat(params2))   
	} 
}
```

그리고 아래와 같이, 부분적용을 적용할 함수와 미리 셋팅할 인자들을 함께 넘겨놓고, 함수를 반환합니다.
```javascript

const sum5 = partial(function(a, b, c, d) {
	return a + b + c + d;
}, 3, 2);

```

```javascript
console.log(sum5(4, 3));
console.log(sum5(3, 2));
console.log(sum5(7, 2));
```

사용법을 보면 커링과 다른 점을 알 수 있습니다. 천천히 실행을 할 때마다, 여러 단항함수를 내뱉는 커링과 달리 부분적용은 일부 인자들을을 미리 받아놓고, 나머지 인자들을 마저 받아서 실행하는 함수를 내뱉습니다.



### 왜 커링을 사용할까요?

그렇다면, 이런걸 도대체 왜 사용할까요? 커링과 부분적용이 얻고자 하는 효과는 명확합니다. 함수의 평가시점을 잘게 쪼개어서,

- 함수를 원하는 시점에 최종 평가하기
- 다항함수의 인자를 줄여나가기

등등의 효과를 얻을 수 있습니다.

덕분에 커링을 잘 활용하면, 코드의 가독성과 효율을 높일 수 있습니다. 

감이 오시나요? 도대체 뭐가 낫다는건지 아직 감이 오지 않는게 당연합니다. 우리가 실전에서 커링을 어디서 적극 활용해 볼 수 있을 지! 코드로 살펴봅시다.


## 인자 줄이기
가장 커링이 활용하기 좋은 건 인자를 줄일 때입니다. '클린 코드' 에서 함수의 인자는 적으면 적을 수록 좋다고 되어 있습니다.
내가 만든 함수가 다행히 인자가 1~2개라면 좋겠지만, 우리가 프로그래밍을 하다보면 인자가 어쩔수 없이 여러개인 경우도 많습니다. 이때! 함수의 인자를 줄여놓고 사용성과 가독성을 올릴 수 있습니다.

예제를 한번 보죠

```javascript

const sum = (a, b, c) => {
	return a + b + c;
};

const sum10 = sum(5)(5);

console.log(sum10(2)); // 12
console.log(sum10(4)); // 14

```

우리는 sum 이라는 함수가 어차피 특정 영역에서 10을 더한 상황에서 할 거라면, sum10을 만들어놓고 인자 한개만 받는게 좋을 것입니다. 잘 안 와닿으시나요?

그럼 우리가 잘 아는 React 로 해보시죠.

```jsx

interface PropsType {
	data: Blog[];
}
const Items = ({ datas }) => {

	const selectItem = (id: number) => {
		...
	}
	
	return (
		<Container>
			{datas.map(({ id, title, text }) => (
				<Item 
					key={id}
					title={title}
					contents={text}
					onPress={() => selectItem(id)}
				/>
			)}
		<Container/>
	)
}
export default Items;

```

좀 아쉽다라고 생가하는 부분이 있으신가요? 제 눈에는 보이는데요. 바로 onPress 입니다. selectItem 라는 함수를 따로 선언해줬음에도 불구하고, onPress 에서 한번 더 함수를 덮어주고 있습니다.

지금은 간단하게 작성한 함수지면, 개인적으로 아쉽습니다. 이때 커링을 활용해보죠

```jsx
const selectItem = curry((id: number) => {
	...
})
```

또는 더 간단하게,

```jsx
const selectItem = (id: number) => {
	return () => {
		...
	}
}
```

이렇게 하면 이제 사용부에서 아래와 같이 할 수 있습니다.

```jsx
	return (
		<Container>
			{datas.map(({ id, title, text }) => (
				<Item 
					key={id}
					title={title}
					contents={text}
					onPress={selectItem(id)}
				/>
			)}
		<Container/>
	)
```

정말 사소하지만, 깔끔! 하죠?


## 무인수
무인수란 말그대로 인수 없는 코드 스타일을 의미합니다. 이때 커링 또는 부분적용이 활용될 수 있습니다. 위에서  커링은 인자를 줄일때 유용한 걸 봤습니다.

그걸 그대로 적용해보죠

```javascript

// 예제 1

const scores = [{ sub: '국어', score: 92 }, { sub: '영어', score: 88 }, { sub: '수학', score: 100 }];

const sum = (a, b) => {
	return a + b;
};

const over = curry((stand, score) => score > stand);

const get = (obj, key) => {
	return obj[key];
}

const getScore = _.partial(get, _, 'score');

let lens = 0;
const setLens = (nums) => {
	lens = nums.length;
}

const result = _.chain(scores)  
    .map(getScore)  
    .filter(over(90))  
    .tap(setLens)  
    .reduce(sum, 0)  
    .value();
				
console.log(result/lens);  // 90점 이상 과목에 대한 평균 -> 96

```

chain 과 tap 이라는 녀석을 쓰기 위해서, lodash 의 힘을 좀 빌렸습니다. 여기서 주목해야할 점은 바로 getScore, over 등등의 인자가 2개 이상인 함수들 조차도, 인수를 넘기는 형태로 함수를 사용하지 않았다는 점입니다.

만약 커링을 쓰지 않았다면 아래와 같은 형태겠죠

```javascript
// 예제 2

const result = _.chain(scores)  
    .map((obj) => {
		return obj['score'];
	})  
    .filter((score) => score > 90))  
    .tap(setLens)  
    .reduce(sum, 0)  
    .value();

```

자! 뭔차이냐? 코드가 더 줄지 않았느냐? 하실 수 있습니다. 하지만!

```javascript
// 예제 1
const get = (obj, key) => {
	return obj[key];
}

// 예제 2
const over90 = (score) => score > 90

```

두 함수를 비교했을 때, 재사용성이 높은 함수는 어떤 것인가요? 당연히 예제 1이죠!!
클린 코드라는 관점에서 재사용성이 높은 코드는 우리가 지향해야할 코드입니다.

그런데! 재사용성을 높이다 보니  인자가 2개가 필요해졌구요!
그렇다보니! map() 의 사용법과 다릅니다.

```javascript

const get = (obj, key) => {
	return obj[key];
}

// !!! Error !!!
// key 라는 인자는 넘겨줄수가 없어요!!
_.map(scores, get)  
```

이때 구원 투수가 등장하는데 그게 바로 커링의 일종인 부분적용입니다.

```javascript
const get = (obj, key) => {
	return obj[key];
}

const getScore = _.partial(get, _, 'score');

_.map(scores, getScore)  
```

덕분에, 우린 함수의 재사용성도 높였구요. 코드의 가독성도 높였습니다. 



함수 조합


평가 늦추기