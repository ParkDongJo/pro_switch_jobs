# 렌더링의 트리거
- ==초기 렌더링인 경우==
- ==state 가 업데이트 된 경우==
	- set 함수로 상태 업데이트 -> 렌더링 대기열에 추가됨 -> 렌더링


# 렌더링 호출

#### 호출
- ==초기 렌더링인 경우==
	- React 루트 컴포넌트 부터 호출한다.
- ==state 가 업데이트 된 경우==
	- 렌더링을 트리거한 컴포넌트를 호출한다.
	- 재귀적 단계
		- A 컴포넌트 렌더링 & B반환 -> B 컴포넌트 렌더링 & C 반환 -> C 컴포넌트 렌더링

#### 계산
- ==**초기 렌더링인 경우**==
	- 태그에 대한 DOM 노드를 생성한다.
- ==**state 가 업데이트 된 경우**==
	- 이전 렌더링 이후 변경된 속성을 계산한다.


> 순수한 계산
> - 동일한 입력에는 동일한 출력을 해야한다. == 동일한 상태 가 주어지면, JSX 는 항상 동일한 결과로 반환해야한다.
> - 이전의 state를 변경해서는 안된다. == 변경사항을 엎는게 아니라 변경사항을 차례대로 처리한다.

> 성능 최적화
> - https://ko.legacy.reactjs.org/docs/optimizing-performance.html 에 있는 몇가지 옵트인 방식으로 최적화를 해볼 수 있다.



# 변경사항 커밋
컴포넌트를 렌더링 한 후 React 는 DOM을 수정한다.

- ==**초기 렌더링인 경우**==
	- appendChild() 라는 DOM API를 사용해서 생성한 모든 DOM 노드를 화면에 표시한다.
- ==**state 가 업데이트**==
	- 계산 단계에서 변경사항으로 계산된 최소한의 작업만 적용해서, DOM에 최신으로 출력될 수 있도록 반영한다.


# 페인팅
렌더링이 완료되고 React DOM을 업데이트 하면, 브라우저가 이를 다시 화면에 그린다.





# 옵트인
-------
### **(클래스 컴포넌트)** 

### **shouldComponentUpdate** / **PureComponent**

- React는 기본적으로 업데이트 시 렌더 트리를 따라 내려가며 렌더를 시도합니다.
- 하지만 어떤 컴포넌트는 props/state가 의미 있게 바뀌지 않았으면 **하위 트리까지 통째로 렌더링을 스킵**해도 됩니다.
- 이때 **shouldComponentUpdate****에서** **false****를 반환**하거나, 대체로는 **React.PureComponent(얕은 비교 기반)**를 써서 불필요 렌더를 줄이는 게 문서에 소개된 “옵트인”입니다. 
    

### **(함수 컴포넌트)** 
### **React.memo**

- 함수 컴포넌트에서는 React.memo로 컴포넌트를 감싸서 **props가 같으면(기본은 얕은 비교) 다시 렌더링을 건너뛰도록** “선택 적용”합니다. 
- 필요하면 비교 함수를 두 번째 인자로 넣어 더 정교하게 제어할 수도 있지만, 대개는 비용/복잡도가 올라가서 “정말 병목일 때만”이 권장 흐름입니다(=성급한 최적화 금지).


## **2) “비싼 계산”을 건너뛰기 (재렌더는 하되, 계산/생성 비용을 줄임)**

### **useMemo**

- 렌더링 중 수행되는 **비싼 계산 결과를 캐시**해서, 의존성이 바뀌지 않으면 다음 렌더에서 재계산을 스킵합니다.
- 문서에서도 “업데이트 시 불필요한 작업을 건너뛰는 데 도움”이고 “성급하게 쓰지 말라(측정/확인하라)”는 톤이 명확합니다. 
### **useCallback**

- 자식에게 넘기는 **함수 prop의 ‘참조 동일성’**을 유지해, (주로 memo로 감싼) 자식이 불필요하게 다시 렌더되는 걸 막는 데 쓰입니다. 
- 핵심은 “함수 자체를 캐시”해서 props 비교에서 매번 “새 함수”로 인식되는 일을 줄이는 겁니다.


## **3) (최신 흐름) React Compiler로 메모이제이션을 “자동화”하되, 도입은 옵트인/점진적으로**


최근 공식 문서는 **React Compiler**를 통해 useMemo/useCallback/React.memo 같은 “수동 메모이제이션”을 **컴파일 단계에서 자동으로 처리**해주는 방향을 강하게 밀고 있습니다. 

- 즉, 전통적 옵트인(개발자가 훅/memo를 직접 박는 방식)을 **대체하거나 크게 줄이는** 접근입니다.
- 그리고 이 컴파일러 자체도 “한 번에 전부”가 아니라 **일부 영역부터 점진 도입(incremental adoption)**하도록 안내합니다. 
    
- 추가로 React Compiler에는 특정 함수에 대해 컴파일러 최적화를 적용하도록 힌트를 주는 **"use memo"** **지시문**도 문서로 존재합니다.