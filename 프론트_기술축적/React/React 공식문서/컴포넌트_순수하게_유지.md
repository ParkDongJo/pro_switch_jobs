
동료분의 의견 
메모리제이션 개념과 흡사해보이는데, 19 이후 React Compiler 를 통해서 메모이제이션이 자동화가 되니까
아래 예제가 바뀔 수도 있지 않을까? 생각이 듭니다.

나의 생각
React Compiler 를 내부 코드도 보면서 어떤 식으로 Compiler 가 돌아갈까를 가볍게 공부해본적이 있는데, 결국은 React Compiler의 결과물은 클로저를 기반으로 메모이제이션을 하고 있었다
[Babel/ReactCompilerBablePlugin](compiler/packages/babel-plugin-react-compiler/src/Babel/RunReactCompilerBabelPlugin.ts)

때문에, 아래 예제와는 조금 거리가 있다고 생각한다. 아래는 확실히 전역 환경에서 메모이제이션을 하면서 불변성이 깨지는 예제가 맞지만,

클로저를 통해서 메모이제이션은 함수형 프로그래밍에서 자주 사용하는 기법중에 하나이고 불변성을 해친다고 볼 수 없다.

```
let guest = 0;

function Cup() {
  // 나쁜 지점: 이미 존재했던 변수를 변경하고 있습니다!
  guest = guest + 1;
  return <h2>Tea cup for guest #{guest}</h2>;
}

export default function TeaSet() {
  return (
    <>
      <Cup />
      <Cup />
      <Cup />
    </>
  );
}

```




나의 생각
사이드 이펙트에 대한 두려움들을 모두가 가지고 있다. 하지만 함수형 프로그래밍에서는 사이드 이펙트가 프로그래밍을 하면서 있을 수 밖에 없다고 한다.

다만 중요한 것은 이런 사이드 이펙트들을 한쪽으로 모으는 것이다.

함수형 아키텍처를 설계를 할때, 함수의 계층을 나누는 것이 중요하다고 생각한다. 가장 순수한 함수들로 부터 시작해서 계층을 점점 쌓아가고 가장 외부와의 접점에서 사이드 이펙트를 일으키는 코드를 둔다던지

이런 설계가 필요하다.