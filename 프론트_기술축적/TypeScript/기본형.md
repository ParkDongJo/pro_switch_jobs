# 2.1 애너테이션 효과적으로 사용하기
여기서 애너테이션은 타입선언을 이야기 한다. 책에서 이야기하는 필수적인 타입 지정은 아래 정도는 가장 중요한 부분이라고 이야기 한다.
- 함수의 매개변수 형식
- 필요하다면 함수의 반환 형식

그 외에 부분에서는 타입추론으로 생략할 수 있다고 이야기 한다.

타입스크립트는 구조적 형식 시스템으로 동작함으로, 값의 형태(형식 == 구조)가 같다면 타입이 서로 호환이 된다.

그래서 아래와 같은 예시를 제시한다.

```typescript
type Person {
	name: string;
	age: number;
}

type Studying = {
	semester: number;
}

type Student = {
	id: string;
	age: number;
	semester: number;
}

function createPerson() {
	return { name: "Stefan", age: 39, semester: 25, id: "XPA" }
}

function printPerson(person: Person) {...}
function studyForAnotherSemester(student: Studying) {...}
function isLongTimeStudent(student: Student) {...}

const me = createPerson();

printPerson(me);
studyForAnotherSemester(me);
isLongTimeStudent(me);

```

Person, Studying, Student 이 세 타입을 모두 구조적으로 호환하는 결과를 내뱉기 때문에, createPerson() 으로 생성한 me 는 타입이 호환된다고 이야기 한다.

단, 여기서 typescript 는 객체 리터럴을 직접 사용했을 때는 엄격한 검사를 거친다.

```typescript
// 객체 리터럴 직접 전달 시 
printPerson({ name: "Stefan", age: 39 }); // ✅ OK 
printPerson({ name: "Stefan", age: 39, semester: 25 }); // ❌ Error 

// 변수를 통해서 전달 
const me = { name: "Stefan", age: 39, semester: 25, id: "XPA" }; printPerson(me); // ✅ OK - 구조적 타이핑 
studyForAnotherSemester(me); // ✅ OK - 구조적 타이핑 
isLongTimeStudent(me); // ✅ OK - 구조적 타이핑
```


# 2.2 any 와 unkown 활용하기
결론은 아래와 같다
- 형식을 끄고 싶은 상황에서 any 사용
- 주의가 필요할 때, 구체적 형식 결정을 우선 다음으로 전달한다는 차원에서 unkown 사용

### any
- any는 never 를 제외한 모든 형식과 호환된다.
- any를 사용할 때는 tsconfig.json 에 noImplicitAny 플래그를 활성해야한다.
- 동작원리를 알고, 문서가 잘 작성되어 있거나, 확실한 상황이라면, 형식에 구애받지 않고 any 를 활용에 진짜 집중할 곳에 집중하는 것도 좋은 방향이다.

### unkown
- any 대신 사용할 순 있다.
- unknown 으로는 아무것도 할 수 없으며, 단지 값을 여기서 저기로 전달 할 수 있을 뿐이다.
- 최종적으로 타입가드, 제어흐름을 이용해 unknown 을 특정 형식으로 구체화 해야한다.

```typescript
function doSomething(value: unknown) {
	if (typeof value === "string") {
	 ...
	} else if (typeof value === "number") {
	 ...
	}
}
```


# 2.3 올바른 객체 선택하기
결론
복합형식 : Array, Function, Class, Tuple, Regex 등등은 object 를 사용한다.
그 외 기본형식: { } 를 사용한다.

### Object
- undefined, null 을 제외한 모든 type 과 호환된다.
- toString() => string 을 가져야함을 엄격하게 체크한다.

### { }
- undefined, null 을 제외한 모든 type 과 호환된다.
- toString() => any 와 같이 엄격하게 체크하진 않는다.

### object
- 복합형식만 지원하고 호환된다.


# 2.4 튜플 형식 사용하기
결론
JavaScript 의 배열은 끝이 정해지지 않은 컬렉션과 같다.
TypeScript 의 type 선언을 통해 Tupple 이라는 type 을 만들어서 사용할 수 있다.

```typescript
type person = [name: string; age: number];

const p = ['DJ', 40]
p[0] = 30; // 오류!
p[1] = false; // 오류!
```

함수에 넘어가는 매개변수들에 대해서도 튜플을 활용하면, 아래와 같이 여러 인자들을 일일이 선언하지 않고, 튜플을 활용해서 가독성과 편의성을 높일 수 있다.

```
function hello(a: string, b: string; c: string) {
}

function hello(...ags: [strin, string, string]) {
}
```


# 2.5 인터페이스와 형식 별칭의 차이 이해하기
결론
- interface
	- 선언합치기 활용
		- lib.d.ts 파일에 활용
		- 외부에 제공하는 라이브러리에서 적합하다
	- namespace 기반 캐싱
		- 확장성과 재사용성이 높아진다.
	- class 와의 궁합
		- class 의 구조를 강제화 할 수 있다
- type
	- 타입 중복에 대해 오류 알림
		- 타입 안전성을 높여야 할때
	- 간단한 type 선언들
	- 더 다양한 type 들을 선언 가능
		- 유니언 타입
		- 튜플
		- 리터럴 타입

# 2.6 함수 오버로드




# 2.7 this 형식
[[this가 가르키는 곳]] 보면 this 에 대해 더 자세히 다루고 있다.




# 2.8 Symbol
심볼은 다른 모든 심볼과 구별되는 고유의 값이 할당된다. 이름이 같거나 주입된 값이 같더라도 서로 겹치지 않는다.

```typescript
const SYMBOL1_TITLE = Symbol('title');
const SYMBOL2_TITLE = Symbol('title');

if (SYMBOL1_TITLE === SYMBOL2_TITLE) {
	// 절대 이 조건이 성립되지 않음
}
```

### 언제 사용하는가
- 객체 또는 모듈 내 한 속성을 만들때
	- private 한 속성
	- 서로 충돌이 안나는 속성
	- 객체에 부가적인 정보를 저장하되, 일반적인 열거에서 제외한 메타데이터 속성

```typescript
const _name = Symbol('name'); 
const _subName = Symbol('name');

class MyClass { 
	constructor() { 
		this[_name] = '숨겨진 이름';
	} 
	getName() { 
		return this[_name]; 
	}
}

const myObj = {
	[_name]: '이름',
	[_subName]: '보조이름'
}

const metadata = Symbol('metadata');

const response = {
	[metadata]: {
		createdAt: new Date()
	},
	data: {
		name: '테스트'
	}
}
```

- 이터러블 또는 메서드 커스터마이징
```typescript
// Symbol.iterator - 이터러블 객체 만들기
const myIterable = {
  [Symbol.iterator]() {
    let i = 0;
    return {
      next() {
        return { value: i++, done: i > 3 };
      }
    };
  }
};

// Symbol.toStringTag - toString() 동작 커스터마이징
class MyClass {
  get [Symbol.toStringTag]() {
    return 'MyCustomClass';
  }
}
```

# 2.9 값과 형식 계층에 대한 이해
typescript 는 JavaScript 라는 값 계층 위에, TypeScript 라는 타입 계층을 올려서 사용한다고 이해하면 좋다.
타입과 관련된 메타정보는 JavaScript 런타임에서 코드 실행 전에 모두 제거된다.

```
|----------|
 TypeScript
|----------|
 JavaScript
|----------|
```

타입 계층에서 값 계층을 이용할 수 없다.
값 계층에서는 타입 계층을 이용할 수 있다.

단!
typeof 또는 is와 같은 타입스크립트 키워드를 이용하면, 타입 계층에서 값 계층을 이용할 수 있다.
```typescript
// 값
const person = {
  name: "DoJo";
}

// 형식
type Person = typeof person;
```