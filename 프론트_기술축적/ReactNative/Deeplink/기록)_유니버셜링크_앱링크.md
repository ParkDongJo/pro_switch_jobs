기존 딥링크는  myapp://path  같은 커스텀 스킴을 사용하는 반면, 유니버셜링크/앱 링크는 표준 HTTPS 스킴을 사용한다

# 앱 링크 (Android)
디지털 에셋링크 (assetlinks.json) 을 만들어 서버에 배포하면, Android 기기는 서버에서 . 이파일을 검색해서 딥링크를 확인한다.


==매칭되는 앱 있을 시==
```
[앱 설치 직후]

   ▼

[OS가 Manifest 확인]

   ▼

[도메인 → /.well-known/assetlinks.json 요청]
[package_name + SHA256 검증]

   ▼
  
[결과를 로컬에 캐싱하여, 앱링크 구성]
```

```
[링크 클릭]

   ▼

[OS가 캐시된 검증 결과 + Manifest 확인]

   ▼

[매칭되는 앱 있음]

   ▼
  
[앱 실행 + 앱페이지 오픈]
```

예시 Manefest
```xml
<intent-filter android:autoVerify="true">
    <action android:name="android.intent.action.VIEW"/>
    <category android:name="android.intent.category.BROWSABLE"/>
    <category android:name="android.intent.category.DEFAULT"/>

    <data
        android:scheme="https"
        android:host="example.com"
        android:pathPrefix="/"/>
</intent-filter>
```


==매칭되는 앱 없을 시==
```
[링크 클릭]

   ▼
  
[OS가 Manifest 확인]

   ▼

[매칭되는 앱 없음]

   ▼

[기본 브라우저로 URL 그대로 열기]
```

실제 example.com 도메인 서버로 요청이 갔을 시, 서버에서의 동작을 정의해둔다.

- 서비스 웹페이지를 열거나
- 302 로 앱스토어에 리다이렉트 시키거나


# 유니버셜 링크 (iOS)

==매칭되는 앱 있을 시==
```
[앱 설치 직후]

   ▼

[iOS가 앱의 Associated Domains 설정을 확인]
[/.well-known/apple-app-site-association 로 요청 후 다운로드]

   ▼

[AASA 내부 appID / path 검증]

   ▼
  
[AASA 파일을 다운로드하여 로컬에 캐싱]
```

```
[링크 클릭]

   ▼
  
[iOS가 캐시된 AASA 기준으로 도메인 + path 매칭 확인]

   ▼

[앱에 NSUserActivity 객체 전달]
[userActivity.webpageURL 가져와서 파싱]

   ▼

[앱페이지 오픈]
```


==매칭되는 앱 없을 시==
```
[링크 클릭]

   ▼
  
[iOS가 캐시된 AASA 기준으로 도메인 + path 매칭 확인]

   ▼

[매칭되는 앱 없음]

   ▼

[safari로 웹페이지 오픈]
```