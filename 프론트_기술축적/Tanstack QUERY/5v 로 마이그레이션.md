https://github.com/ssi02014/react-query-tutorial/blob/main/document/v5.md
23 가지로 정리됨


v4에서는 `useQuery(key, fn, options)`, `useQuery({ queryKey, queryFn, ...options })` 두 형태를 모두 지원했는데 이는 유지보수가 힘들고, 매개 변수 타입을 확인하기 위한 런타임 검사도 필요했기 때문에 오로지 `객체` 형식만 지원하도록 v5에서 변경되었습니다.

해야 할 일
`useQuery(key, fn, options)` 를 모두 `useQuery({ queryKey, queryFn, ...options })` 로 교체한다


`queryClient.getQueryData`, `queryClient.getQueryState`의 인수가 `queryKey`만 받도록 v5에서 수정되었습니다.

해야 할 일
```diff
- queryClient.getQueryData(queryKey, filters)
+ queryClient.getQueryData(queryKey)
```

```diff
- queryClient.getQueryState(queryKey, filters)
+ queryClient.getQueryState(queryKey)
```


useQuery의 옵션인 `onSuccess`, `onError`, `onSettled`가 제거되었습니다
https://tkdodo.eu/blog/breaking-react-querys-api-on-purpose

**useQuery**에서** onSuccess**,** onError **콜백 제거** 이유**
1. 중복 호출 문제.
2. 상태 동기화 중 비일관성 문제
3. 예측 가능하지 않은 버그 발생 가능성.
4. 글로벌 콜백을 사용한 대안 제공.

**대안**
• 전역 수준 콜백 사용.
• meta 필드를 통해 유연한 메시지 설정.
• 데이터 변경을 감지하는 사용자 정의 useEffect 사용.




ReactQuery Code Gen
https://orval.dev/overview



----

## React Query V5
1년 전 로드맵
https://github.com/TanStack/query/discussions/4252
https://www.heropy.dev/p/HZaKIE

## v5 를 통해 풀고자 했던 부분들
https://tanstack.com/blog/announcing-tanstack-query-v5
- 번들사이즈 20퍼센트가 줄었음
- useQuery 에 대한 공통사용을 통합함
- DX를 좀 더 직관적으로 만들려고 노력하였음
- cacheTime -> gcTime
- keepPreviousData + placeholderData
- 공유가능한 mutation state
	- https://github.com/TanStack/query/issues/2304
- [suspense 안정화에 대한 v4 와 v5 의 차이](https://tanstack.com/query/v5/docs/framework/react/guides/suspense)
- [Error boundary reseting]( https://tanstack.com/query/v5/docs/framework/react/guides/suspense/#resetting-error-boundaries)
- [개선된 Sever Rendering](https://tanstack.com/query/v5/docs/framework/react/guides/advanced-ssr#experimental-streaming-without-prefetching-in-nextjs)


## 눈여겨 볼 제안들
### status: pending
- 기존의 isLoading 을 isPending 으로 파생시킴, 새로운 isLoading 은 isPending && isFetching 의 조합으로 파생시킴
		- rename `status: loading` to `status: pending` and the derived boolean `isLoading` to `isPending`
		- introduce a new, derived boolean flag `isLoading` that is implemented as `isPending && isFetching`
		- v4 에서는 status 의 idle 이 제거되고, fetchStatus 가 도입되었고, 여기에 idle 상태가 새롭게 정의됨

- 상태
		- queryStatus: 쿼리 결과의 상태 (loading, success, error) -> “데이터 상태”에 초점 (data가 있는가?)
		- fetchStatus: 네트워크 fetch의 상태 (idle, fetching, paused) -> “네트워크 상태”에 초점 (요청을 하고 있는가?)
		- data: 현재 가지고 있는 데이터 (undefined일 수 있음)
	- https://velog.io/@skawn1228/React-query-Query-Status-Fetch-Status
		- ![[Pasted image 20250531031025.png]]

### Suspense 지원
- suspense 지원 Hooks
- enabled 를 지원하지 않음
	- Suspense 에서 Query 가 직렬 처리 된다는 특성상
	- 그래도 조건부 렌더링을 하려면, 컴포넌트 분리를 통해서 구현해야함
- placeholderData 
- throwOnError 기본적으로 data가 없을 때만 에러 throw
	- 캐시에 data가 존재하면 에러가 발생해도 컴포넌트는 렌더링됨
	- 모든 에러를 ErrorBoundary로 보내고 싶다면 수동으로 throw error 필요
- QueryErrorResetBoundary
- 서버에서 Suspense 사용 가능 (실험적 / by use Next.js)
- useQuery().promise & React.use() (실험적)


### rename
- useErrorboundary 는 너무 React 스럽다
	- 제안 > throwOnError
- cacheTime -> gcTime

### remove
- query 호출에 대한 많은 overload 제거 (기존에 useQuery 총 9개의 overload 가 있었음)
	- 제안 >  useQuery(그 외 hooks들) 에 대한 공통사용을 통합함
	- 덕분에 번들 사이즈 줄이는데, 도움이 되었음
```
useQuery({
  queryKey: ['todos'],
  queryFn: fetchTodos,
  staleTime: 1000 * 20
})
```
- query eror


----


## 프로젝트의 변경사항 목록

1. useQuery() -> useQuery({}) 로 변경


2. suspense 의 사용법이

```
useQuery(..., { suspense: true })
```
에서 아래와 같이 변경됨
```
useQuerySuspense({})
```

다만 여기서, useQuerySuspense 의 options 타입을 보면
enabled, throwOnError, placeholderData 등등이 빠져 있음
```typescript
export interface UseSuspenseQueryOptions<
	TQueryFnData = unknown,
	TError = DefaultError,
	TData = TQueryFnData,
	TQueryKey extends QueryKey = QueryKey,
> extends OmitKeyof<
	UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,
	'queryFn' | 'enabled' | 'throwOnError' | 'placeholderData'
> {
	queryFn?: Exclude<
		UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>['queryFn'],
		SkipToken
	>	

}
```

우선 Suspense 의 동작에 맞게끔 옵션이 빠지게 된건데 useQuerySuspense 의 실제 코드를 보면 아래와 같이
- enabled 는 기본 true 가 들어가 있고
	- enabled 가 false 이면 쿼리가 자동 실행되지 않는다.
- placeholderData 는 undefined 로 기본 설정이 되어 있음

```typescript
'use client'
...

export function useSuspenseQuery<
	TQueryFnData = unknown,
	TError = DefaultError,
	TData = TQueryFnData,
	TQueryKey extends QueryKey = QueryKey,
>	(
	options: UseSuspenseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,
	queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> {

if (process.env.NODE_ENV !== 'production') {
	if ((options.queryFn as any) === skipToken) {
		console.error('skipToken is not allowed for useSuspenseQuery')
	}
}

  
return useBaseQuery({
		...options,
		enabled: true,
		suspense: true,
		throwOnError: defaultThrowOnError,
		placeholderData: undefined,
	},
	QueryObserver,
	queryClient,
) as UseSuspenseQueryResult<TData, TError>

}
```

문제있게 봐야할 곳은 enabled: false 와 suspense 옵션을 함께 사용하고 있던 곳이다.

3. isLoading 의 변화
기존의 isLoading -> isPending
새로운 isLoading == isPending && isFetching

로 사용된다. 이제 isLoading 은 기존의 isInitialLoading 과 동일한 기능을 수행하며, isInitialLoading 이 더이상 사용되지 않는다.

이 부분은 useMutaion() 도 동일하다.

이 부분은 기존의 isLoading 을 모두 isPending 으로 교체했기 때문에 이 부분만 재확인 하면 될것 같다.


4. useInfiniteQuery pageParam
pageParam 을 초기값을 설정하는 방법이 initialPageParam 옵션을 주는 것으로 변경되었다. initialPageParam 을 제대로 셋팅했고 이전의 방법을 잘 제거했는지 다시 한번더 확인하면 될 것 같다.


5. react-query.ts 에서 공용으로 제공하는 파라미터를 기반으로 useQuery 를 감싼 코드들
useQueryWithInitParam 에서 suspense 가 true 인 영역은 useSuspenseQueryWithInitParam 라는 새로운 hooks 를 제공하여 대체하였다. 잘 대체되었는지 확인하고

그런데 useSuspenseQueryWithInitParam 같은 경우 기존의 enabled 를 특정조건에 의해 true false 를 제어하고 있었는데, 이 부분을 아래와 같이 false 이면 아예 호출이 안되게끔 했다.

하지만 이는.. 의도적으로 제어한 코드이며 실제로 이렇게 했을 시 정상 동작을 할지 의문이다.
이 부분들은 테스트를 해봐야한다.

```typescript
export const useSuspenseQueryWithInitParam = <
	TQueryFnData = unknown,
	TError = unknown,
	TData = TQueryFnData,
	TQueryKey extends QueryKey = QueryKey,
>({
	queryKey,
	queryFn,
	initParams,
	...options
}: UseSuspenseQueryOptions<TQueryFnData, TError, TData, TQueryKey> & { initParams?: InitParameters[] }): UseSuspenseQueryResult<TData, TError> => {

	const [searchParam] = useSearchParams();
	const { initQueryParam } = useInitialQueryParameters(initParams);

	const complete = useMemo(() => {
		if (isFalsy(initParams)) return true;
		if (isFalsy(initQueryParam)) return false;
		
		return Boolean(
			initQueryParam.reduce((curr, key) => {
				return curr * Number(!!searchParam.get(key.type));
			}, 1),
		);
	}, [initQueryParam, initParams, searchParam]);
	
	if (!complete) {
		return {} as UseSuspenseQueryResult<TData, TError>;
	}
	
	return useSuspenseQuery<TQueryFnData, TError, TData, TQueryKey>({
		queryKey,
		queryFn,
		...options,
	});

};
```


useQueryWithInitParam 는 사용하는 곳이 1군데 밖에 없고, 타입매칭이 쉽지 않아서 아예 제거해버렸다.

useQueriesTyped 는 타입추론을 위한 커스텀 hooks 인데,

```
Extract<TQueries[ArrayElement], UseQueryOptions>['queryFn']
```

가 함수 타입이 아닌 경우가 있는것 같다. 이에 대해 조건부를 추가하였다. 타입 추론이 제대로 되는지 확인을 해봐야한다.



6. queryClient.xxx() -> queryClient.xxx({})


7. cacheTime 이 gcTime 으로 명칭이 변경되었는데, 이 부분 잘 반영했는지 살펴봐야함





```typescript
// 이전
const { data, isLoading } = useQuery(
	[endpointKeys.CLIENT__GET_VEHICLE_GROUP_LIST],
	() => api.client.group.getVehicleGroupApi({ size: MAX_PAGE_SIZE }),
	onSuccess: () => { ... },
	onError: () => { ... },
	{
		suspense: true,
		enabled: true,
		keepPreviousData: true,
		useErrorBoundary: false
		cacheTime: 0,
	}
);

const { data, isLoading } = useMutation(
  ...
)

const { data, fetchNextPage } = useInfiniteQuery(
  ...
  queryFn: ({ pageParam = 1 }) => api({ page: pageParam, size: initPagination.size }),
)




// 마이그레이셔 후
const { data, error, isPending } = useQuery({
	queryKey: [endpointKeys.CLIENT__GET_VEHICLE_GROUP_LIST],
	queryFn: () => api.client.group.getVehicleGroupApi({ size: MAX_PAGE_SIZE }),
	enabled: true,
	placeholderData: keepPreviousData,
	throwOnError: false,
	gcTime: 0,
});

const { data, error, isPending } = useSuspenseQuery({
	queryKey: [endpointKeys.CLIENT__GET_VEHICLE_GROUP_LIST],
	queryFn: () => api.client.group.getVehicleGroupApi({ size: MAX_PAGE_SIZE }),
	gcTime: 0,
})

useEffect(() => {
  ...
}, [data])

useEffect(() => {
  ...
}, [error])

const { data, fetchNextPage } = useInfiniteQuery({
  ...
  queryFn: ({ pageParam }) => api({ page: pageParam, size: initPagination.size }),
  initialPageParam: 1 
})

const { data, isPending } = useMutation({
  ...
})

queryClient.oooo({ ... })
```



