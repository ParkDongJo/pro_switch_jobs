

# 불변의 값의 필요성
클라이언트 측 개발자들은 앱의 사용시간이 길어질수록 앱 화면에서 문제가 쌓이고 오류가 생길 상황을 겪게 된다.

- 만들게 되는 객체를 최소화 하고
- 관리하는 상태가 적게
- 리프래쉬가 잘 되는 상태로 만드는 것

화면이 오랫동안 정상적으로 동작하게 하는데 유리한 환경이다.


# 불변의 값 Return in Lodash
## \_.sortBy

lodash의 sortBy를 활용하면, ES의 내장함수 sort 보다 훨씬 깔끔하게 정렬을 구현할 수 있다.

```javascript
const user1 = _.sortBy(users, ['user', 'age']);  
log(user1);
  
```

직접 구현했을 때는 아래와 같다
```javascript
// _.sortBy(users, ['user', 'age']) 직접 구현한다고 했을 시  
const user2 = [...users].sort((a, b) => {  
    if (a.user < b.user) return -1;  
    if (a.user > b.user) return 1;  
    if (a.age < b.age) return -1;  
    if (a.age > b.age) return 1;  
    return 0;  
});  
log(user2);
```


## \_.without

without 은 활용도가 생각보다 높지 않다. 리터럴 배열만 가공이 가능하기 때문이다. 최소한 서비스를 개발하면서 {} 또는 [{}] 형태를 많이 쓰게 되는데, 단순히 리터럴 배열만 가능하니 아쉬운 면이 있다.

```javascript
// _.without(array, [values])  
const nums = [2, 1, 2, 3];  
const excluded = _.without(nums, 1, 2);  
log(excluded);
```

## \_.reject

reject 는 filter 를 좀 더 의미있게 사용할 수 있다. ES6의 내장 filter 를 사용하는 것보다 낫다.
또한 조건부를 함수가 아니라 객체 그 자체에 대해서도, 비교할 수 있어서 더더욱 유용하다.

```javascript
const objs = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];

// _.reject(array, [predicate=_.identity])  
// 이런 경우 reject 가 유용하다.  
const excluded3 = _.reject(objs, { 'x': 1, 'y': 2 });  
log(excluded3);
```



## \_.assignin
{} 객체는 이터러블 프로토콜이 아니라서, 이터레이터 방식을 사용할 수 없다. 그렇다보니 내장함수 Object.assign 으로 병합할 때가 있는데, 그것 보다는 lodash 의 assignin 을 활용하는게 더 코드가 깔끔하다

```
// _.assignin(object, [sources])  
// _.extend가 버전업이 되면서, _.assignin으로 변경되었다.  
const object = { 'a': 1 };  
const other = { 'b': 2 };  
const other2 = { 'c': 3 };  
const other3 = { 'd': 4 };  
const other4 = { 'e': 5 };  
  
const assigned = _.assignIn(object, other, other2, other3, other4);
```


## \_.split



## \_.splice



# 객체의 값 복사
객체를 복사하는 건 일반적인 값을 복사하는 것과는 차이가 있다. 객체를 copy 한다는 것은 1차 구조에 대해서만 복사를 한다. 만약 객체가 중첩의 구조를 가지고 있다면 이는 구조적으로 주소값을 통해 데이터를 공유하고 있다. 이는 메모리 효율을 위해서다.

'함수형 코딩' 이라는 책에서는 객체를 카피하는데 2가지를 아래와 같은 개념으로 설명하고 있다.

1. 구조적 공유
2. 깊은 복사

구조적 공유는 
우선 변경이 없는 값들에 대해서는 그대로 두고, 변경이 있는 값들에 대해서만 새로운 객체나 값으로 교체해주는 기법이다. 이는 메모리를 아끼고 효율적으로 데이터를 다룰 수 있다.

깊은 복사는
모든 데이터 계층에 대해 복사를 뜨는 기법이다. 이는 가장 심플하고 안전하다. 다만 그만큼 큰 비용이 든다.


이 책에서도 이에 대한 이야기를 꺼낸다.

## \_.assignIn

사실 해당 함수는 여러 객체{} 를 하나로 병합하는 기능을 수행한다.
병합된 새로운 객체를 뱉어주긴 하지만, 첫 인자로 넣은 객체는 불변이 아닌 값이 계속 더해진다. 즉 복사의 기능을 활용하려면 첫 인자를 {} 빈 객체로 넣어줘야한다.


```javascript
// _.assignin(object, [sources])  
// _.extend가 버전업이 되면서, _.assignin으로 변경되었다.  
const object = { 'a': 1 };  
const other = { 'b': 2 };  
const other2 = { 'c': 3, 'x': { 'z': 1 }};  
const other3 = { 'd': 4 };  
  
const assigned = _.assignIn(object, other, other3);  
log(assigned) // { a: 1, b: 2, d: 4 }
log(object === assigned) // true
  
const assinged2 = _.assignIn({}, other, other2);  
log(assinged2);
//{ a: 1, b: 2, d: 4, e: 5, c: 3, x: { z: 1 } }

```


## \_.defaults & \_.defaultsDeep

defaults 는 왼쪽 객체들에 없는 key/value 만 확장해 간다.
3.10.0 버전 이상 부터 defaultsDeep 이라는 함수도 추가된 걸로 보이는데, 이는 재귀적으로 값을 병합해준다. 그래서 중첩이 되는 구조에도 데이터를 병합해낸다.

아래 예제를 보면 둘의 차이를 확연하게 알 수 있다.

```javascript

log(_.defaults({}, other2, { 'x': { 'z': 1, 'g': { 'h': 11 } } }));
// { c: 3, x: { z: 1 } }

log(_.defaultsDeep({}, other2, { 'x': { 'z': 1, 'g': { 'h': 11 } } }));
// { c: 3, x: { z: 1, g: { h: 11 } } }

```

우리가 실제 프로젝트에서 중첩된 객체 {} 를 많이 사용하는데, 실제로 deepCopy 를 한다면 defaultsDeep() 을 사용하는 것이 좋겠다. 실제로 deepCopy 를 했는지 확인해보면 결과는 아래와 같다

```javascript
const other5 = { 'x': { 'z': 1, 'g': { 'h': 11 } } };  
const newDefaults = _.defaultsDeep({}, other2, other5);  
log(newDefaults);  
// { c: 3, x: { z: 1, g: { h: 11 } } }
  
other5.x.g = { 'h': 22 };  
  
log(newDefaults);
// { c: 3, x: { z: 1, g: { h: 11 } } }

```

보듯이 기존 객체는 새로 만든 객체에 전혀 영향을 미치지 않는다.

deepcopy 를 한다면 한가지 더 함수가 있다.


## \_.clone & \_.cloneDeep

더 잘 알려진 clone 은 defaults 활용법이 비슷할수 있다. 다만 첫 인자가 영향을 받는지 아닌지의 차이일 것 같다.

오히려 4.0.0 에서 새롭게 나온 cloneDeepWith() 살펴보는 게 더 의미가 있을 것 같다.


## \_.cloneDeepWith

