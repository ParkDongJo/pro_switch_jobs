
## 출발하면서

FE 에서 주로 React 를 활용한다면, 함수형 코딩을 피할 수는 없습니다. React 의 흐름은 이미 functional 기반으로 많은 부분들이 설계되고 패턴화 되고 있기 때문입니다.

하지만 함수형 프로그래밍은 코드적 설계 패러다임의 한 종류일 뿐이지 객체지향, 절차지향과 대척점을 이루는 개념이 아닙니다. 구글링을 하다보면 “함수지향 vs. 객체지향” 류의 글들을 보는 경우가 있습니다. 하지만 이는 잘못된 접근입니다. 두 패러다임은 코드를 설계하는데 있어서 함께 응용되는 개념이지, 대척점에 서있는 개념이 아닙니다. 꼭! 이 부분을 짚고 넘어 갑시다

## 함수형의 기법 또는 개념들

정리차원에서 그냥 쭉 나열해보겠습니다.

- 부수효과
    
- 순수함수
    
- 구조적 공유 & 방어적 복사
    
- 일급함수
    
- 고차함수
    
- 콜벡함수
    
- 함수조합
    
- 함수계층
    
- 커링
    
- 부분평가
    
- 평가지연
    
- 모나드
    
- 메모라이즈
    
- 함수형 아키텍처
    

등등 꽤 매력적인 기법들이 있습니다. 특히나 JavaScript는 언어 자체의 특성상 함수형 코딩을 하기에 좋은 이점을 가지고 있습니다. 왜 그런지는 다음 시간에 기회가 있다면, 제가 아는 선에서 공유를 드리겠습니다.

## 부수 효과

부수 효과는 영어로 Side Effect 라고도 표현합니다. 의도하지 않은 결과가 나왔을 때 이런 표현을 씁니다. 잘못된 경우 심각한 버그로도 이어지죠. 그리고 무엇보다 부수효과를 내는 코드들은 테스트 코드를 작성을 상대적으로 어렵게 만듭니다.

하지만 여기서도 몇몇 오해들이 있습니다. 부수 효과는 무조건 나쁜 것일까요?

그렇지 않습니다. 프로그래밍을 하는데 있어서 부수 효과는 때론 필요로합니다. 다만! 끼리끼리 모여질 수 있도록 코드를 잘 분리 시켜줘야합니다.

## 순수 함수

때론 용어가 이해를 가리기도 하죠. 부수효과가 없는 함수를 순수함수라고 하고, 부수효과가 있는 함수를 불순함수 라고 해야할까요?

순수함수의 개념은 동일한 입력을 넣었을 시, 어떠한 상황에서도 동일한 출력값을 리턴하는 함수를 말합니다. 아래와 같은 함수가 있다고 해보겠습니다.

```
const add10 = (n: number) => {
  return n + 10;
}

console.log(add10(2)) // 12
console.log(add10(4)) // 14
```

함수의 입력이 결과값에 영향을 줄 뿐, 이 함수는 그 어떤 다른 영향을 받지 않습니다.

아래 함수를 보죠.

```
let tmp = 0;
const add10 = (n: number) => {
  return n + 10 + tmp;
}

console.log(add10(2)) // 12
console.log(add10(4)) // 14
```

같은 결과를 내고 있습니다. 마찬가지로 2를 넣으면 12가 나오고 4를 넣으면 14가 나옵니다. 하지만 이는 순수함수가 아닙니다.

tmp라는 전역 변수는 부수효과입니다. 지금 당장은 0이라서 동일한 결과를 내고 있지만, 어느 시점에 tmp 의 값이 바꿔서 예상치 못한 결과를 낼지 아무도 장담할 수 없습니다.

이때 add10은 더이상 순수함수가 아닙니다.

## 불변성

그러면 부수효과가 없고 입력, 출력만 낸다면 순수함수 라고 할 수 있을까요? 여기서 우리는 ‘불변성’ 라는 개념을 마주하게 됩니다. 우리가 React 를 다루고 있다면 이 불변성이라는 개념은 자주 접해보셨을 겁니다.

불변성은 ‘최초 할당된 메모리의 값(상태)을 변경하지 않음’ 을 의미합니다.

아래 함수를 보죠.

```
let outer = 1;
const pure(inner: number) => {
  inner = 10;
  return inner;
}

console.log(outer); // 1
console.log(pure(outer)); // 10
console.log(outer); // 1
```

pure() 함수는 outer 에 아무런 영향을 미치지 못했습니다. scope 가 다르니까 당연한거 아냐? 그래요?.. 좀 더 봐보죠.  
이번엔 참조 타입 값을 넘겨보겠습니다.

```
let outer = { name: 'dongjo', age: 38 };
const noPure(inner: number) => {
  inner.age = 20;
  return inner;
}

console.log(outer); // { name: 'dongjo', age: 38 }
console.log(noPure(outer)); // { name: 'dongjo', age: 20 }
console.log(outer); // { name: 'dongjo', age: 20 }
```

noPure() 함수를 거치더니, outer 의 age 값 조차 변경되어버렸습니다. 너무 좋은데요?! ㅎㅎㅎ 갖고 싶은 함수입니다.

우리는 타입을 ‘원시 타입’과 ‘참조 타입’ 으로 나눌수 있는데요.

  
함수로 넘어온 파라미터가 원시타입일 경우 ‘값의 복사’가 이뤄집니다. 하지만 참조 타입일 경우 ‘주소 복사’가 이뤄 집니다. 이때 ‘참조 타입’을 함수 내에서 받아서 내부의 값들을 함부로 변경시켜버리면, 결국 넘겨받은 원래의 ‘참조 타입’ 값의 주소를 찾아가서 내부의 값이 변경됩니다. 결국! 불변성이 깨져 버립니다.

함수에 넘어온 값들이 불변성을 보장할 수 없다면, 이 함수는 더이상 순수 함수라고 할 수 없습니다. 때문에 우리가 순수함수를 만들면서, 파라미터로 ‘참조 타입’이 넘어온다면 불변성을 보장해주기 위해 의도적으로 사전 작업을 해줘야 합니다.

어떤 작업들을 해줘야 하는거냐? 더 자세한건 다음 시간에 공유 드리겠습니다.

## 그래서 핵심은?!

지루하고 당연한 기본 개념들을 설명했는데요. 이 기본 개념들을 통해 우리가 실무해서 신경써야 할 점은 아래 내용입니다.

> 함수를 만들 때, 부수효과와 순수함수를 분리시키고 함수의 계층을 설계하자!

이 결론을 도달하기 위해 우리는

- 함수지향과 객체지향은 대척되는 개념이 아니다.
    
- 부수효과는 필요하다. 하지만 순수함수로 부터 분리시켜야한다.
    
- 순수함수를 늘릴려고 노력해야한다. 그러기 위해서는 어떤 함수가 순수함수인지 알아야합니다.
    

## 왜 이런 기본적인걸 이야기 하는거야!!

네 매우 기본적이라.. 저도 민망하지만 그만큼 중요한 개념입니다. 이는 함수형 프로그래밍이 왜 테스트 친화적인 코드를 만들어내는지를 알 수 있는 대표적인 개념들입니다.

특히 함수형 코딩은 단위 테스트를 작성하는데 유리합니다. 동일한 입력을 넣으면 불변성이 보장된 동일한 출력값을 내는 함수들이 많아진다면, 우리는 특정 함수를 테스트 할때 입력값에 대한 출력값만 비교해주면 됩니다.  
  
아래와 같이요.

```
it('add10 실행을 실행 했을 때,',  () => {
  expect(add10(2)).toBe(12);
  expect(add10(4)).toBe(14)
});
```

그리고 하위 함수들이 안정성이 검증되었다면, 그 하위 함수들로 조합된 상위 함수는 이미 검증이 됐다고 볼 수 있습니다.  
아래 예를 들어보죠.

score() 함수가 내부적으로 add10() 과 minus1() checkZero, 을 사용하고 있고,

```
const score = (answer: 'Y'|'N', currScore: number) => {
  if (answer = 'Y') {
    return add10(currScore);
  }
  return checkZero(
    currScore,
    minus1
  );
}
```

이때 add10(), minus1(), checkZero() 들이 순수함수, 고차함수로서 이미 검증이 완료된 함수라면, score() 함수는 이미 검증된 함수라고 볼 수 있습니다.

```
it('score 를.. 굳이 테스트 할 필요가 있어??? ,',  () => {
  expect(score('Y', 10)).toBe(20);
  expect(score('N', 10)).toBe(9);
  expect(score('N', 0)).toBe(0);
});
```

단위테스트는 변화에 취약하다는 의견도 있는데요. 저는 이는 ‘반은 맞고’, ‘반은 틀렸다’ 라고 봅니다. 이 부분은 함수의 계층설계를 통해 어느정도 극복할 수 있습니다.

변화가 적은 함수들을 하위에 두고, 변화가 많은 함수들은 상위 함수로 올립니다. 상위함수들은 테스트가 검증된 하위 함수들로 함수 조합을 해가는 거죠.

지금까지 가볍게 함수형 코딩에 대해서 정리해봤습니다. 다음 공유 시간에는 이어서 좀 더 유용한 개념들을 공유드리겠습니다.